\chapter{Implementation}

	In order to achieve the goals set in this project, two separate pieces of 
	software and one piece of hardware were written. The software programs are 
	two different implementations of a reference shader. The first of these was 
	written in GLSL for traditional graphics hardware (in our case it was 
	tested on a GeForce GTX 1060M ), and the second is written in an assembly 
	language we designed for the Sphere Tracing processor. Both of these 
	shaders are described in section \ref{implshader}. The hardware is 
	comprised of a multi-core programmable parallel processing unit designed 
	for the Sphere Tracing algorithm, detailed in section \ref{implproc}.

	\section{Reference Shader} \label{implshader}

		The essentials of the Sphere Tracer is a simple while-loop. It
		calculates distance to the closest object in the scene by sampling
		the distance field and testing whether it's value is less than a
		predefined epsilon. If true, the ray has hit an object; the
		corresponding pixel's color is calculated and the loop is
		terminated, unless the material of the object in question is
		defined as being reflective.


		\subsection{GLSL Based}

			The shader which is made to run on conventional graphics hardware
			was made in the high-level shading language GLSL (short for OpenGL
			Shading Language). It works by running the program for each pixel
			the shader is rendered on, using the screen-coordinates as input.

			Beyond the actual sphere tracing loop there are also some initial calculations
			done to set up the origin and direction of the ray, which is done
			using screen coordinates. This needs to be done for each pixel
			being rendered.

			Coloring a pixel in a scene is based on the material ID
			assigned to the first object that the ray intersects. The color
			can then be either calculated by a material formula or be 
			derived from a texture lookup. True 3D materials can be done by
			texturing but this generally needs a large data set and thus a 
			formula is mostly preferred where three dimensional materials 
			are employed. 2D texturing can be done by projecting points from
			a flat image onto a simple geometric shape  which is more or less 
			enveloping the object in question. This is called texture-mapping 
			and commonly uses simple shapes like planes, cubes, spheres and 
			cylinders. 

		\subsection{GPU Assembler Based}

			In the assembler version that runs on our own hardware there is
			initially a single thread. This thread will create one new thread
			for each pixel on the screen, and this thread will calculate what 
			color the pixel should have and then terminate. 




	\section{Processor Unit} \label{implproc}

		The properties of the ray marching algorithm as described above led to
		the decision of designing a GPU architecture that does not utilize
		multi-ALU SIMD with lockstepping to the same extent as traditional
		graphics processors. Instead, a solution with slightly simpler
		independent cores was decided upon. This is similar to reasoning
		employed by \cite{Woop2005} for a ray-tracing hardware design.

		\subsection{Instruction Set}

			A representation for distance functions was also designed. It is
			implemented as a reverse polish notation inspired stack based 
			instruction set.

			There are a total of four instruction types with different
			instruction encodings, their layout in memory is shown in figure
			\ref{encodingfig}, and the type of instructions are:

			\begin{description}
				\item[C-type] instructions are for control flow, that is, 
					instructions that affect the global queue or frame buffer or
					terminate the current thread. C-type instructions can be 
					conditionally executed, based on the condition encoded in
					the two highest bits in the opcode. The condition can not
					be \texttt{11}, as this is reserved for the other 
					instruction types.

				\item[D-type] instructions, which encode arithmetic- and vector  %???
					stack instructions. These operate only on the internal stack
					in the core. They can take up to six arguments and return up
					to three return values. D-type instructions can be split up 
					in chunks using the \texttt{next} instruction, where the 
					last computed result will be accumulated using the minimum
					automatically by the core. This is useful for encoding 
					distance functions.

				\item[V-type] instructions deal with memory accesses. The
					\texttt{p} bit encodes whether this access is for pack
					(mutable) or read-only memory.

				\item[R-type] instructions are not currently in use.
			\end{description}

		\subsection{Execution Model}

			The processor contains a global queue that is shared among all
			cores, onto which all threads that are ready for execution wait
			until a core is ready to start executing them.

			Each shader thread has 16 mutable registers that are automatically
			loaded into the core when execution starts. These registers are
			also saved when execution pauses and they are also copied whenever
			a thread spawns a new child. The instruction \texttt{setval} can be
			used to change the value of a register, and the instruction
			\texttt{pack} reads the value of a register.

			All calculations are performed with intermediate values stored on a
			stack, with the ability to move any values between the stack and
			any of the registers using the \texttt{setval} and \texttt{pack}
			instructions.

			There are three main instructions for control flow: \texttt{pushq},
			\texttt{pushf}, and \texttt{drop}. 

			Threads can spawn new threads at any time using the instruction
			\texttt{pushq}: this will cause the core to make a copy of all of
			the registers and push it onto the global queue, where another (or
			the same) core may later access them and start executing from the
			instruction pointer register (\texttt{r0}).

			Threads can also terminate execution in two ways. Executing the
			instruction \texttt{drop} will terminate the thread and discard all
			registers. Executing \texttt{pushf} will terminate the thread and
			discard all values except the pixel pointer (\texttt{r1}) and color
			register (\texttt{r2}), which will be sent to the frame buffer in
			order to be displayed on the screen.

			This set of instructions for control flow might initially seem to
			be neither useful nor easy to implement but they are powerful
			enough to implement for all branching that is needed in our ray
			marchers efficiently while being restrictive enough to make
			instruction memory accesses very predictable.

			In addition to this, each core can accelerate finding the minimum 
			distance for a set of distance functions using a built-in 
			accumulator, together with the instructions \texttt{next} and 
			\texttt{accum}. Because of this, distance functions can be written
			without any regard for how the shader that called them works, and
			this very common operation is automated, reducing the size of each
			distance function slightly.

		\subsection{Square Roots}

			Calculating distances is an integral part of the algorithm, so a
			good square root implementation was considered important for
			achieving good performance. Several different approaches for this
			were considered.

			Firstly, using an iterative method like Goldschmidt's or the
			babylonian method was considered. These require an initial starting
			value, which is usually generated using a look-up table. We found a
			different and very fast method for generating an initial rough
			guess of the square root of any number without the need for a
			look-up table\footnote{It is unlikely that we are the first to
			discover this approximation method due to its simplicity, however
			we were unable to find anyone else mentioning its use}. An 8-bit
			version of this circuit is shown in figure \ref{orsqrt}, and an
			improved but slightly more expensive version is showed in figure
			\ref{orsqrt2}.  The basic working principle is based on the fact
			that the square root of a number har roughly half as many digits as
			the original number. In the version with slightly improved accuracy
			the placement of the extra wires is based on the bit pattern of
			$\sqrt{2}$.

			In order to improve the accuracy of this method another design was
			considered in which the input was both rounded up and down to 
			values where the simple method was very accurate and the result was
			then linearly interpolated between these roots. This linear 
			interpolation requires only a multiplication and a couple of 
			additions, but choosing upper and lower seed values is a more 
			complex problem. Choosing the two geometrically closest powers of 
			two was tested because the or-gate square root circuit is very
			accurate for powers of two, but this is not the only possible 
			choice.

			Another algorithm for calculating square roots is the
			\emph{Shifting nth root algorithm}, also known as \emph{Dijkstras
			square root algorithm}, which calculates the square root one digit
			at a time. A \texttt{c} implementation of this algorithm is shown
			in figure \ref{sqrtc}. Initially, this algorithm does not seem like
			a good canditate for a high performance hardware implementation,
			but several important optimizations are possible when unrolling it
			combinatorially. Most of the additions can be reduced to bitwise
			logic operations already when computing it in software, as shown in
			figure \ref{sqrtcopt}. In a combinatorial hardware implementation,
			these bitwise operations can be removed entirely by simply moving
			wires around, yeilding a logic cost of 0. The only remaining
			operations is therefore the subtraction on line 2, and the
			conditional assignment of \texttt{num} on line 5. The cost of the
			subtraction can be significantly reduced because \texttt{res}
			approximates the result one bit every step, meaning most bits are
			zeroed at any given iteration. On average, only 25\% of this
			subtraction is needed. This turned out to result in a design very
			similar to the PARSQRT implementation by \cite{japaneseSQRT}.
