\chapter{Implementation}
	
	To realize this project, two separate pieces of software and one piece of
	hardware were written. The hardware is comprised of a multi-core
	programmable parallell processing unit designed for the ray-marching
	algorithm, detailed in section \ref{implproc}, and the software programs
	are two different implementations of a reference shader.  The first of
	these was written in GLSL for traditional graphics hardware (in our case it
	was tested on a ???), and the second is written in an assembly language we
	designed for the ray-marching processor. Both of these shaders are
	described in section \ref{implshader}.
	
	\section{Processor Unit} \label{implproc}

		The properties of the ray marching algorithm as described above led to
		the decision of designing a GPU architecture that does not utilize
		multi-ALU SIMD with lockstepping to the same extent as traditional
		graphics processors. Instead, a solution with slightly simpler
		independent cores was decided upon. This is similar to reasoning
		employed by \cite{Woop2005} for a ray-tracing hardware design.
	
		\subsection{Instruction Set}

			A representation for distance functions was also designed. The
			representation that was chosen is a reverse polish notation
			inspired stack based instruction set.
	
			There are a total of four instruction types with different
			instruction encodings, their layout in memory is shown in figure
			\ref{encodingfig}, and the type of instructions are:

			\begin{description}
				\item[C-type] instructions are for control flow, that is, 
					instructions that affect the global queue or frame buffer or
					terminates the current thread. C-type instructions can be 
					conditionally executed, based on the condition encoded in
					the two highest bits in the opcode. The condition can not
					be \texttt{11}, as this is reserved for the other 
					instruction types.

				\item[D-type] instructions, which encode arithmetic- and vector
					stack instructions. These operate only on the internal stack
					in the core. They can take up to six arguments and return up
					to three return values. D-type instructions can be split up 
					in chunks using the \texttt{next} instruction, where the 
					last computed result will be accumulated using the minimum
					automatically by the core. This is useful for encoding 
					distance functions.
					
				\item[V-type] instructions deal with memory accesses. The
					\texttt{p} bit encodes whether this access is for pack
					(mutable) or read-only memory.

				\item[R-type] instructions are not currently in use.
			\end{description}
		
		\subsection{Execution Model}

			The processor contains a global queue that is shared among all
			cores, onto which all threads that are ready for execution waits
			until a core is ready to start executing them.
			
			Each shader thread has 16 mutable registers that are automatically
			loaded into the core when execution starts. These registers are
			also saved when execution pauses and they are also copied whenever
			a thread spawns a new child. The instruction \texttt{setval} can be
			used to change the value of a register, and the instruction
			\texttt{pack} reads the value of a register.
	
			All calculations are performed with intermediate values stored on a
			stack, with the ability to move any values between the stack and
			any of the registers using the \texttt{setval} and \texttt{pack}
			instructions.
	
			There are three main instructions for control flow: \texttt{pushq},
			\texttt{pushf}, and \texttt{drop}. 
			
			Threads can spawn new threads at any time using the instruction
			\texttt{pushq}: this will cause the core to make a copy of all of
			the registers and push it onto the global queue, where another (or
			the same) core may later access them and start executing from the
			instruction pointer register (\texttt{r0}).
			
			Threads can also terminate execution in two ways. Executing the
			instruction \texttt{drop} will terminate the thread and discard all
			registers. Executing \texttt{pushf} will terminate the thread and
			discard all values except the pixel pointer (\texttt{r1}) and color
			register (\texttt{r2}), which will be sent to the frame buffer in
			order to be displayed on the screen.
	
			This set of instructions for control flow might initially seem to
			be neither useful nor easy to implement but they are powerful
			enough to implement for all branching that is needed in our ray
			marchers efficiently while being restrictive enough to make
			instruction memory accesses very predictable.

			In addition to this, each core can accelerate finding the minimum 
			distance for a set of distance functions using a built-in 
			accumulator, together with the instructions \texttt{next} and 
			\texttt{accum}. Because of this, distance functions can be written
			without any regard for how the shader that called them works, and
			this very common operation is automated, reducing the size of each
			distance function slightly.
		
		\subsection{Implementation considerations}
	
	\section{Reference Shader} \label{implshader}
		
		A reference shader was written in order to be able fulfill the
		requirement of comparing the performance of our graphics processor with
		that of a modern traditional graphics card. 
	
		\subsection{GLSL Based}
	
		\subsection{}
