Automatically generated by Mendeley Desktop 1.17.9
Any changes to this file will be lost if it is regenerated by Mendeley.

BibTeX export options can be customized via Preferences -> BibTeX in Mendeley Desktop

@article{Phong1975,
author = {Phong, Bui Tuong and Tuong, Bui},
doi = {10.1145/360825.360839},
file = {::},
issn = {00010782},
journal = {Communications of the ACM},
keywords = {computer graphics,graphic display,hidden surface removal,shading},
month = {jun},
number = {6},
pages = {311--317},
publisher = {ACM},
title = {{Illumination for computer generated pictures}},
url = {http://portal.acm.org/citation.cfm?doid=360825.360839},
volume = {18},
year = {1975}
}
@article{Tommiska,
abstract = {In this paper, an area-efficient implementation of a fast converging square root algorithm is presented. The design of special arithmetic operations differs in many ways from the traditional tasks that digital designers are used to, and the role of parameterizibility and mapping of mathematical algorithms into digital hardware is discussed. Certain real-world applications requiring the use of the square root operator are presented, and it is argued, that implementing special arithmetic operations directly in hardware offers significant speed advantages over the conventional approach of implementing them in software. The mathematical algorithm of the square root operator is described, and its applicability to an implementation in digital logic is presented. It also is shown, that the the square root operator can be efficiently implemented without the need to resort to multiplications or divisions, which is advantageous in terms of both area and timing.},
author = {Tommiska, Matti T},
file = {::},
title = {{AREA-EFFICIENT IMPLEMENTATION OF A FAST SQUARE ROOT ALGORITHM}}
}
@misc{InigoQuilez,
author = {{Inigo Quilez}},
title = {{Modeling with Signed Distance Fields}},
url = {http://www.iquilezles.org/www/articles/sdfmodeling/sdfmodeling.htm},
urldate = {2017-05-08}
}
@article{Suzuki2010,
abstract = {SUMMARY Ray tracing is one of the most popular techniques for gen-erating photo-realistic images. Extensive research and development work has made interactive static scene rendering realistic. This paper deals with interactive dynamic scene rendering in which not only the eye point but also the objects in the scene change their 3D locations every frame. In order to realize interactive dynamic scene rendering, RTRPS (Ray Tracing based on Ray Plane and Bounding Sphere), which utilizes the coherency in rays, objects, and grouped-rays, is introduced. RTRPS uses bounding spheres as the spatial data structure which utilizes the coherency in objects. By using bounding spheres, RTRPS can ignore the rotation of moving objects within a sphere, and shorten the update time between frames. RTRPS utilizes the coherency in rays by merging rays into a ray-plane, assuming that the sec-ondary rays and shadow rays are shot through an aligned grid. Since a pair of ray-planes shares an original ray, the intersection for the ray can be com-pleted using the coherency in the ray-planes. Because of the three kinds of coherency, RTRPS can significantly reduce the number of intersection tests for ray tracing. Further acceleration techniques for ray-plane-sphere and ray-triangle intersection are also presented. A parallel projection tech-nique converts a 3D vector inner product operation into a 2D operation and reduces the number of floating point operations. Techniques based on frustum culling and binary-tree structured ray-planes optimize the order of intersection tests between ray-planes and a sphere, resulting in 50{\%} to 90{\%} reduction of intersection tests. Two ray-triangle intersection techniques are also introduced, which are effective when a large number of rays are packed into a ray-plane. Our performance evaluations indicate that RTRPS gives 13 to 392 times speed up in comparison with a ray tracing algorithm with-out organized rays and spheres. We found out that RTRPS also provides competitive performance even if only primary rays are used.},
author = {Suzuki, Ken-ichi and Kaeriyama, Yoshiyuki and Komatsu, Kazuhiko and Egawa, Ryusuke and Ohba, Nobuyuki and Kobayashi, Hiroaki},
doi = {10.1587/transinf.E93.D.891},
file = {::},
keywords = {bounding sphere,bounding volume,computer graphics,intersection test,ray tracing},
number = {4},
title = {{A Fast Ray-Tracing Using Bounding Spheres and Frustum Rays for Dynamic Scene Rendering}},
year = {2010}
}
@article{Yoo2009,
abstract = {A novel approach which uses the distance fields based on cell subdivision and an implicit surface interpolation based on the radial basis function is proposed in order to get an accurate and error-free offset model of arbitrary shapes composed of a large number of triangle meshes. In the method, the space bounding the original model is divided into smaller cells. For the efficient calculation of distance fields, valid cells which will generate a portion of offset model are selected previously by the proposed detection algorithm. These valid cells are divided again into much smaller voxels which assure required accuracy. At each voxel, the distance fields are created by calculating the minimum distances between the corner points of voxels and the triangle meshes. For the more efficient calculation of distance fields, valid vertices among the triangle meshes which will generate minimum distances with current cell are selected by checking the intersection between current cell and a cone prism generated at each vertex of triangle meshes. In addition, a new approach based on an implicit surface interpolation scheme is proposed to perform two types of offsetting operations including uniform and non-uniform offsetting in the same framework. In the method, a smooth implicit surface is generated from the discrete offset distance values given by the user. After generating the whole distance fields, the offset surface was constructed by using the conventional marching cube algorithm together with mesh smoothing scheme. The effectiveness and validity of this new offset method was demonstrated by performing numerical experiments for the various types of triangle meshes.},
author = {Yoo, Dong Jin},
doi = {10.1007/s12541-009-0081-5},
file = {::},
isbn = {1229-8557},
issn = {12298557},
journal = {International Journal of Precision Engineering and Manufacturing},
keywords = {3d offsetting,Cell subdivision,Cone prism intersection,Distance fields,Implicit function,Triangular net},
number = {4},
pages = {131--142},
title = {{General 3D offsetting of a triangular net using an implicit function and the distance fields}},
volume = {10},
year = {2009}
}
@inproceedings{Reiner2011,
abstract = {Modeling appealing virtual scenes is an elaborate and time-consuming task, requiring not only training and experience, but also powerful modeling tools providing the desired functionality to the user. In this paper, we describe a modeling approach using signed distance functions as an underlying representation for objects, handling both conventional and complex surface manipulations. Scenes defined by signed distance functions can be stored compactly and rendered directly in real-time using sphere tracing. Hence, we are capable of providing an interactive application with immediate visual feedback for the artist, which is a crucial factor for the modeling process. Moreover, dealing with underlying mathematical operations is not necessary on the user level. We show that fundamental aspects of traditional modeling can be directly transferred to this novel kind of environment, resulting in an intuitive application behavior, and describe modeling operations which naturally benefit from implicit representations. We show modeling examples where signed distance functions are superior to explicit representations, but discuss the limitations of this approach as well. ?? 2011 Elsevier Ltd. All rights reserved.},
author = {Reiner, Tim and M{\"{u}}ckl, Gregor and Dachsbacher, Carsten},
booktitle = {Computers and Graphics (Pergamon)},
doi = {10.1016/j.cag.2011.03.010},
file = {::},
isbn = {00978493 (ISSN)},
issn = {00978493},
keywords = {Distance functions,Implicit surface rendering,Implicit surfaces,Interactive modeling},
number = {3},
pages = {596--603},
title = {{Interactive modeling of implicit surfaces using a direct visualization approach with signed distance functions}},
volume = {35},
year = {2011}
}
@article{Zhou2008,
abstract = {We present a real-time algorithm called compensated ray marching for rendering of smoke under dynamic low-frequency environment lighting. Our approach is based on a decomposition of the input smoke animation, represented as a sequence of volumetric density ﬁelds, into a set of radial basis functions (RBFs) and a sequence of residual ﬁelds. To expedite rendering, the source radiance distribution within the smoke is computed from only the lowfrequency RBF approximation of the density ﬁelds, since the highfrequency residuals have little impact on global illumination under low-frequency environment lighting. Furthermore, in computing source radiances the contributions from single and multiple scattering are evaluated at only the RBF centers and then approximated at other points in the volume using an RBF-based interpolation. A slice-based integration of these source radiances along each view ray is then performed to render the ﬁnal image. The high-frequency residual ﬁelds, which are a critical component in the local appearance of smoke, are compensated back into the radiance integral during this ray march to generate images of high detail. The runtime algorithm, which includes both light transfer simulation and ray marching, can be easily implemented on the GPU, and thus allows for real-time manipulation of viewpoint and lighting, as well as interactive editing of smoke attributes such as extinction cross section, scattering albedo, and phase function. Only moderate preprocessing time and storage is needed. This approach provides the ﬁrst method for real-time smoke rendering that includes single and multiple scattering while generating results comparable in quality to ofﬂine algorithms like ray tracing.},
author = {Zhou, Kun and Ren, Zhong and Lin, Stephen and Bao, Hujun and Guo, Baining and Shum, Heung-Yeung},
doi = {10.1145/1360612.1360635},
file = {::},
isbn = {9781450301121},
issn = {07300301},
journal = {ACM Transactions on Graphics},
keywords = {environment lighting,figure 1,ment lighting,multiple scattering,participating media,perfect hashing,real-time rendering of smoke,sig-,single scat-,smoke volume can change,tering,the appearance of a,under dynamic environ-},
number = {3},
pages = {1},
title = {{Real-time smoke rendering using compensated ray marching}},
url = {http://doi.acm.org/10.1145/1360612.1360635. http://doi.acm.org/10.1145/1360612.1360635},
volume = {27},
year = {2008}
}
@inproceedings{Han2007,
author = {Han, Jeonghun and Ki, Hyunwoo and Oh, Kyoungsu},
booktitle = {2007 International Conference on Computational Science and its Applications (ICCSA 2007)},
doi = {10.1109/ICCSA.2007.46},
file = {:Users/kuma/Library/Application Support/Mendeley Desktop/Downloaded/Marghany, Hashim, Cracknell - 2007 - Holographic interferomatery for modelling rate change of shoreline from AIRSAR data(2).pdf:pdf},
isbn = {0-7695-2945-3},
month = {aug},
pages = {499--504},
publisher = {IEEE},
title = {{GPU Ray Marching for Real-Time Rendering of Participating Media}},
url = {http://ieeexplore.ieee.org/document/4301187/},
year = {2007}
}
@misc{Baaij2009,
abstract = {Functional hardware description languages are a class of hardware description languages that emphasize on the ability to express higher level structural properties, such a parameterization and regularity. Due to such features as higher-order functions and polymorphism, parameterization
in functional hardware description languages is more natural than the parameterization support found in the more traditional hardware description languages, like VHDL and Verilog. We develop a new functional hardware description language, C?asH, that borrows both the syntax and
semantics from the general-purpose functional programming language Haskell. In many existing functional hardware description languages, a circuit designer has to use language primitives that are encoded as data-types and combinators within Haskell. In C?asH on the other hand, circuit designers build their circuits using regular Haskell syntax. Where many existing languages encode state using a so-called delay element within the body of a function, C?asH specifications explicitly encode state in the type-signature of a function thereby avoiding the nodesharing problem most other functional hardware description languages face. To cope with the direct physical restrictions of hardware, the familiar dynamically sized lists found in Haskell are replaced with fixed-size vectors. Being in essence a subset of Haskell, C?asH
inherits the strong typing system of Haskell. C?asH exploits this typing system to specify the dependently-typed fixed-size vectors, be it that the dependent types are ?fake?. As the designers of Haskell never set out to create a dependently typed language, the fixed-size vector specification suffers slightly from limits imposed by the typing system. Still, the developed fixed-size vector
library presents a myriad of functionality to an eventual circuit designer. Besides having support for fixed-size vectors, C?asH also incorporates two integer type primitives. C?asH can be used to develop more than just trivial designs, exemplified by the reduction circuit designed with it. The C?asH design  f this reduction circuit runs only 50{\%} slower than
a hand-coded optimized VHDL design, even though this first generation C?asH compiler does not have any optimizations whatsoever. With the used FPGA resources being in the same order as the resources used by the hand-coded VHDL we are confident that this first-generation compiler is indeed well behaved. Much has been accomplished with this first attempt at developing a new functional hardware
description language, as it already allows us to build more than just trivial designs. There are however many possibilities for future work, the most pressing being able to support recursive functions.},
author = {Baaij, C},
month = {dec},
title = {{C$\lambda$asH : from Haskell to hardware}},
url = {http://essay.utwente.nl/59482/},
year = {2009}
}
@inproceedings{Bjesse1998,
address = {New York, New York, USA},
author = {Bjesse, Per and Claessen, Koen and Sheeran, Mary and Singh, Satnam and Bjesse, Per and Claessen, Koen and Sheeran, Mary and Singh, Satnam},
booktitle = {Proceedings of the third ACM SIGPLAN international conference on Functional programming  - ICFP '98},
doi = {10.1145/289423.289440},
file = {::},
isbn = {1581130244},
issn = {0362-1340},
number = {1},
pages = {174--184},
publisher = {ACM Press},
title = {{Lava}},
url = {http://portal.acm.org/citation.cfm?doid=289423.289440},
volume = {34},
year = {1998}
}
@inproceedings{Appel1968,
address = {New York, New York, USA},
author = {Appel, Arthur and Arthur},
booktitle = {Proceedings of the April 30--May 2, 1968, spring joint computer conference on - AFIPS '68 (Spring)},
doi = {10.1145/1468075.1468082},
file = {::},
pages = {37},
publisher = {ACM Press},
title = {{Some techniques for shading machine renderings of solids}},
url = {http://portal.acm.org/citation.cfm?doid=1468075.1468082},
year = {1968}
}
@article{Raa2015a,
abstract = {C$\lambda$aSH is a functional hardware description language in which structural
descriptions of combinational and synchronous sequential hardware can be
expressed. The language is based on Haskell, from which it inherits abstraction
mechanisms such as, the support of polymorphism and higher-order functions.
Recursion is another fundamental and commonly used abstraction mechanism in
Haskell. In contrast with Haskell, the support of recursion in C$\lambda$aSH is
currently limited. This is considered a shortcoming by many C$\lambda$aSH users.

Data-dependent recursive functions pose a problem for the current
implementation of C$\lambda$aSH. Currently, these recursive function definitions are
unrolled by the compiler, in an attempt to produce finite circuits. In the case
of data-dependent recursive functions, such finite circuit descriptions often
cannot be found using unrolling, as it would require infeasibly large circuits,
capable of handling all possible arguments.

This thesis focuses on extending the C$\lambda$aSH compiler with support of
data-dependent recursion. This is established by describing a formal rewrite
method, based on the continuation passing style transformation. This method
transforms recursive function descriptions to a corresponding circuitry,
capable of executing the recursive function. A detailed description of the
generated stack architecture is provided in the form of C$\lambda$aSH descriptions.
The resulting circuits, produced by applying the methodology, are elaborated
and synthesis results of those circuitries are discussed.},
author = {te Raa, I.},
file = {:Users/kuma/Library/Application Support/Mendeley Desktop/Downloaded/Unknown - Unknown - thesis.pdf:pdf},
title = {{Recursive functional hardware descriptions using C$\lambda$aSH}},
url = {http://essay.utwente.nl/68804/},
year = {2015}
}
@article{Whitted1980a,
author = {Whitted, Turner and Turner},
doi = {10.1145/358876.358882},
file = {::},
issn = {00010782},
journal = {Communications of the ACM},
keywords = {computer animation,computer graphics,raster displays,shading,visible surface algorithms},
month = {jun},
number = {6},
pages = {343--349},
publisher = {ACM},
title = {{An improved illumination model for shaded display}},
url = {http://portal.acm.org/citation.cfm?doid=358876.358882},
volume = {23},
year = {1980}
}
@misc{JamieWong2016,
author = {{Jamie Wong}},
title = {{Ray Marching and Signed Distance Functions}},
url = {http://jamie-wong.com/2016/07/15/ray-marching-signed-distance-functions/},
urldate = {2017-03-24},
year = {2016}
}
@article{Singh2010,
abstract = {Compact representation of geometry using a suitable procedural or mathematical model and a ray-tracing mode of rendering fit the programmable graphics processor units (GPUs) well. Several such representations including parametric and subdivision surfaces have been explored in recent research. The important and widely applicable category of the general implicit surface has received less attention. In this paper, we present a ray-tracing procedure to render general implicit surfaces efficiently on the GPU. Though only the fourth or lower order surfaces can be rendered using analytical roots, our adaptive marching points algorithm can ray trace arbitrary implicit surfaces without multiple roots, by sampling the ray at selected points till a root is found. Adapting the sampling step size based on a proximity measure and a horizon measure delivers high speed. The sign test can handle any surface without multiple roots. The Taylor test that uses ideas from interval analysis can ray trace many surfaces with complex roots. Overall, a simple algorithm that fits the SIMD architecture of the GPU results in high performance. We demonstrate the ray tracing of algebraic surfaces up to order 50 and nonalgebraic surfaces including a Blinn's blobby with 75 spheres at better than interactive frame rates.},
author = {Singh, Jag Mohan and Narayanan, P. J.},
doi = {10.1109/TVCG.2009.41},
file = {::},
isbn = {1077-2626},
issn = {10772626},
journal = {IEEE Transactions on Visualization and Computer Graphics},
keywords = {GPU rendering.,Implicit surfaces,Ray tracing},
number = {2},
pages = {261--272},
pmid = {20075486},
title = {{Real-time ray tracing of implicit surfaces on the GPU}},
volume = {16},
year = {2010}
}
@article{Johnsson2014,
abstract = {At Spark Vision, independent component images, each containing a part of the rendered geometry, are layered to create complete images. Due to the assumption of independence; reflections cannot be accurately rendered. A screen-space method for adding reflections to a rendered image using buffers for geometry and surface properties is proposed. Reflections are traced using an approximation of ray tracing. The goal is to allow for the continued use of component images with reflections added as a post-processing effect in real time. The method outlined allows for perfect and glossy reflections comparable to the quality of commercial ray tracers for optimal scenes. However, it fails to capture reflections of objects that are not visible from the camera view-point except for cases in which these are part of a pre-defined surrounding environment. The method itself allows for dynamic scenes, camera settings and surface properties including BRDFs if used as an off-line renderer. Due to demands of image quality, time constraints and the lack of GPU support a method for caching the rays is proposed based on assumption of a static geometry. The caching method allows for arbitrary variations in lighting, textures and reflection strength as well as limited variations of normal mapping and surface shininess. This method achieves acceptable running times for the intended application.},
author = {Johnsson, Mattias},
file = {::},
publisher = {Chalmers University of Technology},
title = {{Approximating ray traced reflections using screenspace data}},
url = {http://studentarbeten.chalmers.se/publication/193772-approximating-ray-traced-reflections-using-screenspace-data},
year = {2014}
}
@article{Sutikno,
abstract = {Abstrak Makalah ini menyajikan metode perhitungan digit-demi-digit yang dioptimalkan untuk menyelesaikan perhitungan akar kuadrat yang rumit dalam perangkat keras, sebagai algoritma sederhana yang diusulkan untuk implementasi pada field programmable gate array (FPGA). Prinsip utama dari metode ini adalah operasi-operasi penggeseran dua-bit dan pengurang-multipleks, untuk mendapatkan implementasi yang lebih sederhana dan perhitungan yang lebih cepat. Algoritma ini telah digunakan untuk implementasi akar kuadrat biner tak bertanda 32-bit dan 64-bit berbasis FPGA secara sukses. Hasil penelitian menunjukkan bahwa metode yang diusulkan paling efisien sumber daya perangkas keras, bila dibandingkan metode lainnya. Selain itu, strategi ini dapat dengan mudah dikembangkan untuk implementasi akar kuadrat yang lebih besar. Kata kunci: perhitungan angka-oleh-digit, FPGA, Square Root Abstract This paper presents an optimized digit-by-digit calculation method to solve complicated square root calculation in hardware, as a proposed simple algorithm for implementation in field programmable gate array (FPGA). The main principle of proposed method is two-bit shifting and subtracting-multiplexing operations, in order to achieve a simpler implementation and faster calculation. The proposed algorithm has conducted to implement FPGA based unsigned 32-bit and 64-bit binary square root successfully. The results have shown that proposed method is most efficient of hardware resource compare to other methods. In addition, the strategy can be expanded to larger number easily.},
author = {Sutikno, Tole},
file = {::},
issn = {1693-6930},
keywords = {FPGA,Square Root,digit-by-digit calculation},
title = {{AN OPTIMIZED SQUARE ROOT ALGORITHM FOR IMPLEMENTATION IN FPGA HARDWARE}}
}
@article{Hart1996,
abstract = {Sphere tracing is a new technique for rendering implicit surfaces that uses geometric distance. Sphere tracing marches along the ray toward its Þrst intersection in steps guaranteed not to penetrate the implicit surface. It is particularly adept at rendering pathological surfaces. Creased and rough implicit surfaces are deÞned by functions with discontinuous or undeÞned derivatives. Sphere tracing requires only a bound on the magnitude of the derivative, robustly avoiding problems where the derivative jumps or vanishes. It is an e¦cient direct visualization system for the design and investigation of new implicit models. Sphere tracing e¦ciently approximates cone tracing, supporting symbolicpre Þltered antialiasing. Signed distance functions for a variety of primitives and operations are derived.},
author = {Hart, John C},
doi = {10.1007/s003710050084},
file = {::},
issn = {01782789},
journal = {The Visual Computer},
keywords = {distance,implicit surface,lipschitz condition,ray tracing,solid},
number = {10},
pages = {527--545},
pmid = {20635080},
title = {{Sphere tracing: a geometric method for the antialiased ray tracing of implicit surfaces}},
volume = {12},
year = {1996}
}
@inproceedings{Wylie1967,
address = {New York, New York, USA},
author = {Wylie, Chris and Romney, Gordon and Evans, David and Erdahl, Alan},
booktitle = {Proceedings of the November 14-16, 1967, fall joint computer conference on - AFIPS '67 (Fall)},
doi = {10.1145/1465611.1465619},
file = {::},
pages = {49},
publisher = {ACM Press},
title = {{Half-tone perspective drawings by computer}},
url = {http://portal.acm.org/citation.cfm?doid=1465611.1465619},
year = {1967}
}
@article{Hart1989,
author = {Hart, J. C. and Sandin, D. J. and Kauffman, L. H.},
doi = {10.1145/74334.74363},
file = {::},
issn = {00978930},
journal = {ACM SIGGRAPH Computer Graphics},
month = {jul},
number = {3},
pages = {289--296},
title = {{Ray tracing deterministic 3-D fractals}},
url = {http://portal.acm.org/citation.cfm?doid=74334.74363},
volume = {23},
year = {1989}
}
@inproceedings{Putra2013,
abstract = {Square root operation is one of the basic important operation in digital signal processing. It will calculate the square root value from the given input. This operation is known hard to implement in digital hardware because of the complexity of its algorithm. There were many researches related to this topic to obtain the optimum design between area consumption and speed. Regarding this condition, we propose an alternative square root algorithm which is based on two approaches, digital binary input decomposition and iterative calculation. Its fixed-point digital hardware implementation is very simple, low complexity, and resource-efficient. It doesn't need any correction adjustments and directly produces accurate value of square root result and remainder in (N/2)+1 clock cycles, which N represents the wordlength of input. This design has been synthesized for FPGA target board Altera Cyclone II EP2C35F672C6 and produced good results in resource consumption and speed. {\textcopyright} 2013 IEEE.},
author = {Putra, Rachmad Vidya Wicaksana},
booktitle = {Proceedings - International Conference on ICT for Smart Society 2013: "Think Ecosystem Act Convergence", ICISS 2013},
doi = {10.1109/ICTSS.2013.6588110},
file = {::},
isbn = {9781479901456},
keywords = {Novel square root algorithm,fixed-point,iterative calculation,low complexity,resource-efficient,simple},
title = {{A novel fixed-point square root algorithm and its digital hardware design}},
year = {2013}
}
@article{Li,
abstract = {Square root operation is hard to implement on FPGAs because of the complexity of the algorithms. In this pa-per, we present a non-restoring square root algorithm and two very simple single precision floating point square root implementations based on the algorithm on FPGAs. One is low-cost iterative implementation that uses a traditional adderlsubtractor. The operation latency is 25 clock cy-cles and the issue rate is 24 clock cycles. The other is high-throughput pipelined implementation that uses mul-tiple adderlsubtractors. The operation latency is 15 clock cycles and the issue rate is one clock cycle. It means that the pipelined implementation 1s capable of accepting a square root instruction on every clock cycle.},
author = {Li, Yamin and Chu, Wanming},
file = {::;::},
title = {{Implementation of Single Precision Floating Point Square Root on FPGAs}}
}
@inproceedings{Woop2005,
abstract = {Recursive ray tracing is a simple yet powerful and general approach for accurately computing global light transport and rendering high quality images. While recent algorithmic improvements and optimized parallel software implementations have increased ray tracing performance to realtime levels, no compact and programmable hardware solution has been available yet.This paper describes the architecture and a prototype implementation of a single chip, fully programmable Ray Processing Unit (RPU). It combines the flexibility of general purpose CPUs with the efficiency of current GPUs for data parallel computations. This design allows for realtime ray tracing of dynamic scenes with programmable material, geometry, and illumination shaders.Although, running at only 66 MHz the prototype FPGA implementation already renders images at up to 20 frames per second, which in many cases beats the performance of highly optimized software running on multi-GHz desktop CPUs. The performance and efficiency of the proposed architecture is analyzed using a variety of benchmark scenes.},
address = {New York, New York, USA},
author = {Woop, Sven and Schmittler, J{\"{o}}rg and Slusallek, Philipp},
booktitle = {ACM SIGGRAPH 2005 Papers on   - SIGGRAPH '05},
doi = {10.1145/1186822.1073211},
file = {::},
pages = {434},
publisher = {ACM Press},
title = {{RPU: A Programmable Ray Processing Unit for Realtime Ray Tracing}},
url = {http://portal.acm.org/citation.cfm?doid=1186822.1073211},
year = {2005}
}
@article{Sciences,
abstract = {In this paper, we obtain a generalized version of the well-known distance function family L p norm. We prove that the new functions satisfy distance function properties. By using these functions, convex symmetric shapes can be described as loci, the set of points which are in equal distance from a given point. We also show that these symmetric convex shapes can be easily parameterized. We also show these distance functions satisfy a Lipschitz type Condition. We provide a fast ray marching algorithm for rendering shapes described by these distance functions. These distance func-tions can be used as building blocks for some implicit mod-eling tools such as soft objects, constructive soft geometry, freps or ray-quadrics.},
author = {Sciences, Visualization},
file = {::},
title = {{Generalized Distance Functions}}
}
@article{Kakela2016,
abstract = {Photorealistic rendering relies on informative descriptions of its scenes. In particular, the material properties of 3D objects is important to achieve convincing results. The material of an object details how it interacts with light, for instance the color, transparency, and the sharpness of its reflections. What arises in practice is finding a brief description that allows for a wide range of materials to be represented, while preserving photorealism - in other words, a practical material system. These constraints mean that the material parameters should be few and easy to understand, and creating the material definitions themselves must be simple. This report outlines a shading model that attempts to deal with these issues, and presents a collection of base material types that exposes only a few, but powerful, parameters for artists to work with.},
author = {K{\"{a}}kel{\"{a}}, Aki},
file = {::},
publisher = {Chalmers University of Technology},
title = {{A practical shading model for ray tracing}},
url = {http://studentarbeten.chalmers.se/publication/246061-a-practical-shading-model-for-ray-tracing},
year = {2016}
}
@article{Korndorfer2014,
abstract = {In this paper we present several performance and quality enhancements to classical sphere tracing: First, we propose a safe, over-relaxation-based method for accelerating sphere tracing. Second, a method for dynamically preventing self-intersections upon converting signed distance bounds enables controlling precision and rendering performance. In addition, we present a method for significantly accelerating the sphere tracing intersection test for convex objects that are enclosed in convex bounding volumes. We also propose a screen-space metric for the retrieval of a good intersection point candidate, in case sphere tracing does not converge thus increasing rendering quality without sacrificing performance. Finally, discontinuity artifacts common in sphere tracing are reduced using a fixed-point iteration algorithm. We demonstrate complex scenes rendered in real-time with our method. The methods presented in this paper have more universal applicability beyond rendering procedurally generated scenes in real-time and can also be combined with path-tracing-based global illumination solutions.},
author = {Kornd{\"{o}}rfer, Johann and Stamminger, Marc and Keinert, Benjamin},
doi = {10.2312/stag.20141233},
file = {:Users/kuma/Library/Application Support/Mendeley Desktop/Downloaded/Keinert et al. - 2014 - Enhanced Sphere Tracing.pdf:pdf},
journal = {STAG: Smart Tools {\&} Apps for Graphics},
keywords = {Computer Graphics Forum,EUROGRAPHICS},
pages = {8},
title = {{Enhanced Sphere Tracing}},
url = {http://erleuchtet.org/{~}cupe/permanent/enhanced{\_}sphere{\_}tracing.pdf},
year = {2014}
}
@article{Chen2012,
abstract = {Functional programming languages offer a high degree of abstractions and clean semantics, which are desirable for hardware descriptions. This short historical survey is about functional languages specifically created for hardware design and verification. It also includes those hardware languages or formalisms which are strongly influenced by functional programming style.},
author = {Chen, Gang},
doi = {10.5402/2012/271836},
file = {::},
journal = {International Scholarly Research Network ISRN Electronics},
title = {{A Short Historical Survey of Functional Hardware Languages}},
volume = {11},
year = {2012}
}
