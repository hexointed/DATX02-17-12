\chapter{Introduction} 	
%	\section{Background} 
	During the early '90s many types of real time rendering algorithms were 
	developed and tested \cite{TODO}. This was possible because they ran in 
	software on the CPU (Central Processing Unit), and could thus be easily altered and enhanced. 
	Photo realistic rendering could be done using a method called Ray Tracing, 
	but this was slow\cite{TODO}. Improvements were made to this method and 
	one similar algorithm is called Sphere Tracing. This could be used to render
	3D fractals\cite{TODO}, but it was still too slow to render complex
	geometry in real time\cite{TODO}. Better graphics rendering (fast real 
	time graphics) was a key selling point among competing computer systems, so 
	to improve rendering speed, the computer industry moved towards dedicated 
	hardware based 	graphics rendering\cite{TODO}. These systems was almost 
	exclusively using polygon-based rendering, unsuitable for most Sphere Tracing 
	algorithms. Today, 3D graphics cards have become more programmable and the 
	last 5 years have seen a small resurgence in the use of Sphere Tracing 
	rendering\cite{TODO}. Simple scenes can now be rendered using Sphere Tracing 
	in real time using state-of-the-art consumer 3D graphics cards. However the 
	full potential of the algorithm is not achievable on current GPUs 
	due to the underlying architecture being designed for polygon rendering to a 
	large extent\cite{TODO}. This project examines the performance potentials of 
	graphics cards based on the Sphere Tracing algorith. 
	
	\section{Project goals}
	
		The main goal for this project is to design and implement a basic GPU 
		architecture that is designed to efficiently execute the Sphere Tracing 
		algorithm. In striving towards efficiency, we examine Sphere Tracing in 
		order to find possible optimizations, both algorithmic and hardware 
		based.
		
	\section{Scope}

		Writing a GPU for the first time, even a smaller one, and doing it well is
		a large undertaking for a single bachelors project. The project is therefore
		instead done on a best-effort basis where we try to implement the novel parts
		of the design, while leaving out generally well researched systems such as
		cache and memory management. 
