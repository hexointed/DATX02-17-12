\chapter{Discussion}
	
	\section{Method}
		
		\subsection{\clash}

			For this project \clash was chosen as hardware description language.
			\clash is based on the functional programming language Haskell, and
			is relatively new and not yet fully stable. It differs from 
			traditional hardware description languages in that 

			One thing that \clash offers that proved to be very useful is the 
			avalability of a command-line repl. This improved testing and 
			debugging possibilities significantly, and was very useful in order
			to be able to quickly write and test new modules.

		\subsection{Hardware design}

			Many design decisions during the development of the gpu were not
			thoroughly researched or performance tested against possible
			alternatives. It is clear that doing so would have been desirable,
			both in order to improve performance of the resulting design and to
			get a better understanding of the possible design space. 
			Unfortunately, proper performance evaluation for all design 
			decisions would be very time consuming, and there was not enough 
			time for this during this project.

	\section{Results}
		
		\subsection{Software Shader}
			The shader performed as expected, a conventional graphics card is 
			capable of rendering scenes with low scene complexity. However 
			scenes can easily be made to look a lot more complex than they are, 
			for example by using modfields or fractals. On the hardware we 
			tested our shader on (Geforce GTX 1060) 20 relective sphere can
			be rendered in real time in fullHD using our performance enhancing 
			algorithm.

			One thing that could be done to improve performance is to let the
			processor handle object related math, such as object and camera 
			positioning. Currently if objects in the scenes are supposed to 
			move without doing it manually, they have to be moved using 
			mathematical functions. These functions are then evaluated for 
			each march step, for each pixel.

			The method used to remove objects from the distance field should
			not be used the way it is currently used, although the current way
			certainly improves performance. Currently each ray calculates the
			distance to each object to decide whether it will collide or not. 
			A better implementation would be to go through the objects of the 
			and decide which pixels the object will cover, however we do not
			have time or knowledge to implement this. 

			Infinite planes requires a lot of computing power to render. One 
			way to render infinite planes with a smaller performance-penalty 
			might be to calculate where the ray will hit the plane without 
			using the loop, however this has not been investigated. 


		
		\subsection{GPU} 
