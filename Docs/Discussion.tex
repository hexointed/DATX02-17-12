\chapter{Discussion}
	
	\section{Method}
		
		\subsection{\clash}

			For this project \clash was chosen as hardware description language.
			\clash is based on the functional programming language Haskell, and
			is relatively new and not yet fully stable. It differs from 
			traditional hardware description languages in that 

			One thing that \clash offers that proved to be very useful is the 
			avalability of a command-line repl. This improved testing and 
			debugging possibilities significantly, and was very useful in order
			to be able to quickly write and test new modules.

		\subsection{Hardware design}

			Many design decisions during the development of the gpu were not
			thoroughly researched or performance tested against possible
			alternatives. It is clear that doing so would have been desirable,
			both in order to improve performance of the resulting design and to
			get a better understanding of the possible design space. 
			Unfortunately, proper performance evaluation for all design 
			decisions would be very time consuming, and there was not enough 
			time for this during this project.

	\section{Results}
		
		\subsection{Software Shader}

			The shader performed as expected, a conventional graphics card is 
			capable of rendering scenes with low scene complexity. However 
			scenes can easily be made to look a lot more complex than they are, 
			for example by using modfields or fractals. On the hardware we 
			tested our shader on (Geforce GTX 1060) 20 relective sphere can
			be rendered in real time in fullHD using our performance enhancing 
			algorithm.

			One thing that could be done to improve performance is to let the
			processor handle object related math, such as object and camera 
			positioning. Currently if objects in the scenes are supposed to 
			move without doing it manually, they have to be moved using 
			mathematical functions. These functions are then evaluated for 
			each march step, for each pixel.

			The method used to remove objects from the distance field should
			not be used the way it is currently used, although the current way
			certainly improves performance. Currently each ray calculates the
			distance to each object to decide whether it will collide or not. 
			A better implementation would be to go through the objects of the 
			and decide which pixels the object will cover, however we do not
			have time or knowledge to implement this. 

			Infinite planes requires a lot of computing power to render. One 
			way to render infinite planes with a smaller performance-penalty 
			might be to calculate where the ray will hit the plane without 
			using the loop, however this has not been investigated. 


		
		\subsection{GPU} 
		
			The project originally intended to create a simple single-core GPU
			that could fully render a scene given enough time, and then add on
			components as time allowed. As happens with projects like these,
			every design decision one makes clarifies what further needs to be
			done and reveals previously unseen flaws in the design that needs
			to be resolved. In the end we implemented the core and enabled
			multiple cores running in parallel utilizing a global queue, with
			some caveats. While the implementation works and can be simulated
			for up to 128 cores it cannot be compiled in a reasonable amount of
			time and even when compiled for only four cores, the result
			serializes to a layout bigger than the FPGA we had access to. We
			identified this being due to idioms used rather than a general flaw
			in the architecture meaning that we could probably reduce the
			layout drastically utilizing BRAMs instead of FLUTs without having
			to change our design to a large extent. 
			
			If we were to continue the work in a future project we would
			rewrite the basic core in a number of ways, pushing it out to FPGA
			to verify our design choices and try to be more empiric before
			extending further with more modules and ideas. 
