\chapter{Discussion}
This chapter will lift our thoughts on our result, our theoretical not yet implemented optimizations and
what future work is possible from this point in time.
	
	\section{Results}
		
		\subsection{Software Shader}
		
			The few optimizations that were implemented improved performance more than anticipated.
			There are many optimizations that are yet to be implemented and tested
			and it's hard to estimate the potential achievable performance. The
			only thing that is certain is that there are massive performance 
			potentials that can be achieved.

			There are great limitations in what could be done with the shader because
			of the language that we chose to implement it in, GLSL. It offers nothing 
			more than a way to write a program which will run on a per-pixel basis
			and put the result on the screen. Because of this, CPU-GPU cooperation is not possible
			and that comes with consequences.

			Modern graphics engines not only does a lot of work on the
			CPU but it has granular control over the GPU, whereas we have no control
			at all. Things such as object positioning, frustum culling, etc. should be 
			done by the CPU, not the GPU. This kind of implementation can 
			not be done in GLSL and therefore a high-performance sphere tracer should be done not in 
			GLSL but in a lower-level language.

			Although GLSL has it's limits it still has some very attractive 
			features, it was easy to learn because the syntax has much in common
			with java, which we've studied. The time it takes to develop new 
			features and test them is short. The purpose of the software shader 
			was to study the algorithm, implement and test optimizations and
			develop new features. For the purposes of this sphere tracer GLSL
			was a perfect fit.

		
		\subsection{GPU} 
		
			The project originally intended to create a simple single-core GPU
			that could fully render a scene given enough time, and then add on
			components as time allowed.
			Every design decision one makes clarifies what further needs to be
			done and reveals previously unseen flaws in the design that needs
			to be resolved. In the end we implemented the core and enabled
			multiple cores running in parallel utilizing a global queue, with
			some caveats. While the implementation works and can be simulated
			for up to 1024 cores we have only successfully synthesized 16 cores. 
			
			If we were to continue working ong on this project another workflow
			would be adopted when developing the GPU. More detailed planning is 
			required in the early stages and empiric testing of different 
			implementations is required along the entire development to reach
			the best possible solution.

	\section{Optimizations}

		\subsection{Ray grouping}
		
			Ray grouping is an optimization that lowers the number of
			computations the GPU have to perform. Also by lowering the number of
			computations it increases the speed of the GPU.
			
			It works like the name implicates by grouping adjacent rays
			together. If a specific pixel N is to be rendered we group the
			adjacent pixels into a "combined pixel". Then we march along the
			ray of N. If any of the other pixels are not inside the minimum
			distance spheres (MDS) the combined pixel is split up into two
			smaller groups. Each of the groups then repeat the first step again
			individually along their new center pixel's ray. This is repeated a
			number of times depending on the scene.  The closer to a target it
			gets, more subgroups will be created due to the MDS's volumes will
			decrease.
			
			This optimization was implemented and we achieved an increase in
			performance as excepted. The optimization decreases the number of
			computations made by the formula ? below.  Sum of $\sum_1^s(1/N_s)$
			where N = number of pixels in the group and s = number of groups

			%#picture of ray grouping

		\subsection{Bounding spheres}
			
			Although an increase in performance could be seen using this method,
			it can also be used in ways that decreases the performance. By
			setting up a too large boundnig sphere or my setting it up with few
			objects or simply objects that are far apart.

			To use this optimiztion efficiently the objects inside a bounding 
			sphere should never come far apart and the sphere should be exactly 
			the right size.

		\subsection{Orthogonal culling}

			The performance gain from this optimization exeeded our 
			expectations. This could probably be further improved by using
			another way to create the sphere tracer than GLSL. 

			However great the performance gain the way this is implemented
			is still far from the optimal solution, currently it performs orthogonal 
			culling on all the objects in the scene per pixel. Instead,
			culling should be done on a per-object basis and calculate
			which rays an object intersects, this way fewer calculations would
			have to be performed and optimally they would be performed on the
			CPU.

			This method could work together with the Bounding Sphere 
			optimization. Instead of projecting single objects onto the ray,
			bounding spheres could be culled, decreasing the number of 
			orthogonal projections that has to be made. This too was tested 
			and an increase in performance was observed.

	\section{Future work}

		\subsection{GPU-CPU cooperation}

			In the current implementation everything is performed on the GPU,
			including object transformations and culling. Currently if objects 
			in the scene are supposed to move they have to be moved using 
			mathematical functions, such as sinus. These functions are then evaluated for 
			each march step. This is essentially wasted computing power and
			could be performed on the CPU as is standard in modern graphics
			engines.


		\subsection{Plane-ray intersection}

			Infinite planes currently require a lot of computing power to render. When
			the camera is oriented so that the field of view is along an infinite
			plane some rays will travel parallell to the plane. These rays will march 
			equally long steps until their max number of steps has been taken or
			the max range has been reached, without hitting anything. This will 
			cause some rays to draw computing power without ever being able to
			hit the plane anyway. Some rays that should hit the plane will fail
			to do so because of to many steps taken, making it look like the plane 
			has an edge because after a certain range it is no longer being rendered.

			% FIGUR SOM FÖRKLARAR

			Another way to render infinite planes might be to 
			calculate if the ray will intersect the plane, and if so where it 
			will intersect. This would eliminate the issue of not being able 
			to render the horizon and might also increase performance.

			One potential problem is that because no distance field evaluations 
			are performed, it might be hard to perform operations such as CSG or
			mathematical deformations on planes rendered this way. Another is 
			that every time we add more features that isn't "pure" sphere tracing
			the complexity of the program increases, if too many are added the 
			advantages of the individual optimizations will decrease.

		\subsection{Overstepping}

			Bounding spheres technique is somewhat similar to the normal sphere
			tracing. The difference is that when you march you march to the
			edge of the MDS and then you march to the next MDS edge. With
			overstepping technique you march a small distance further
			outside the MDS edge. You then compare the original MDS with the
			new MDS if these two spheres overlap in any way we can march that
			little bit further. By marching that little bit further, decrease
			in the number of times marched is achieved. Giving an increase in
			performance. 
			
			%LÄNKA TILL MENDELEY-PAPER
