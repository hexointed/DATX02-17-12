Sphere Tracing:
	
	Vårt projekts mål har varit att utreda en alternativ grafikrenderingsmetod 
	som kallas Sphere Tracing, och utifrån detta, designa en grafikprocessor 
	optimerad för denna. Detta ville vi göra eftersom man kan se att prestandan 
	för metoden, när den körs på en konventionell GPU, blir kraftigt begränsad. 
	Den kan därmed inte uppnå sin fulla potential eftersom dagens 
	grafikhårdvara är designad för polygonbaserad grafikrendering.
	
	Varför just Sphere Tracing?  För att motivera vårt intresse börjar vi med 
	att kort beskriva hur metoden fungerar, samt några sätt att förbättra 
	algoritmen, som vi kom fram till under utredningsfasen.
	
	- How Sphere Tracing works.
		Sphere Tracing är en variant av sk Ray Tracing, vilket är en 
		grafikrenderingsmetod baserad på att projicera strålar, från en kamera, 
		mot en uppsättning av 3D-Objekt. Det objekt som strålen träffar först 
		avgör vilken färg den korresponderande pixeln på skärmen kommer att få. 
		Detta kräver mycket datorkraft då man ofta måste lösa 
		differentialekvationer för att hitta skärningspunkterna mellan strålen  
		och objekten. Sphere Tracing är ett alternativ till att hitta denna 
		skärningspunkt, vilket görs genom att först definiera alla objekt som 
		sk distansfunktioner. Dessa är funktioner som tar en given 3d-koordinat 
		och returnerar avståndet till den punkt på funktionsytan som ligger 
		närmast in-koordinaten. Detta möjliggör en effektiv ray-marching längs 
		strålen, vilket ger högre prestanda än konventionell Ray Tracing. 
		(bilderbilder...)
				
	 - optimizations
		Describe each
		Show with/without optimizations to show fps difference
		visa visuellt, demonstrera hastighetsförbättring?
	- Software shader	
		berätta att dessa optimeringar är implementerade och testade i en sk 
		shader, ett program som körs på en GPU i en vanlig speldator. 
		(ge visuellt exempel med flowchart)		

	- Vad är då Sphere Tracing bra för?
		Denna algoritm fungerar väldigt annorlunda än polygonrendering, och blir
		därför intressant då den kan vara väldigt snabb på många
		grafikrenderingsmetoder som traditionella polygonrenderare har svårt
		för. Exempel på detta visas här i vår shader, som visar hur ytan på en
		sfär kan se mjuk ut, oavsett zoom-nivå. I polygonmodellen syns skarpa
		kanter vid inzoomning, och skulle man öka antalet polygoner för att
		klara kraftig inzoomning så skulle prestandan istället sänkas alltför
		mycket. (visa inzoomning av 2 sfärer närbild), 
		mjuk geometri-blending mellan objekt (kan visas med metabollarna), äkta
		reflektion/refraktion (visa nån fin interreflektion, t.ex i
		metabollarna), 
		[permuterbar geometrirepetition]
			Även repetition av objekt i alla dimensioner går att göra med en 
			fast hastighetskostnad, till skillnad från det klassiska fallet som 
			har en linjärt ökande kostnad för antal utritade objekt. Varje 
			repeterat objekt kan skilja sig från sina grannar då dess utseende 
			kan varieras och animeras med hjälp av t.ex dess position eller id. 
			Detta medför att stora fält av intressant geometri kan renderas 
			extremt snabbt.	(visa animerat våg-sfär-fält),

		Ytterligare saker: penumbra-skuggning (inigos bilder?),	
		tredimensionella material,  (kanske bara skriva dessa i text på slides)

Processor:
	
	- Architecture overview
	- Assembler

	Utöver detta har vi också byggt en GPU, eftersom ett av målen med projektet
	var att designa hårdvara som är gjord för Sphere Tracing. GPU:n som vi 
	designade blev också en mer generell parallellprocessor, eftersom vi tyckte
	att det ökade möjligheterna för att enkelt kunna implementera de 
	optimeringar som vi diskuterade tidigare på processorn.

	För arkitekturen i sig beslutade vi att lägga mindre fokus på lockstepping
	än traditionella grafikkort, då alla rays kan variera kraftigt i antal
	steg, vilka objekt som är nära, samt när de är klara. Kärnorna i vår GPU
	har alltså lite mer kontrolllogik per beräkningsenhet än traditionella
	grafikkort, men mindre, och därmed fler, kärnor än en CPU. Tillsammans med
	kärnorna behövs ett sätt att representera alla de strålar som behöver
	beräknas. 

	Vi ville också, om möjligt, kunna skapa nya strålar on demand för att
	enkelt kunna implementera t.ex. reflektioner och refraktioner, som är
	relativt enkla att göra med raymarching, och som vore tråkiga att gå miste
	om. Vi valde därför att designa GPU:n så att alla shaders som kör på den
	kör i en slags trådar, och att varje tråd får möjligheten att skapa nya
	trådar. Sedan lade vi till en kö som alla kärnor kunde kommunicera med, där
	kärnorna kan lägga upp nya trådar, och hämta trådar för att börja exekvera.

	[Bild Arkitektur]

	Detta visade sig vara en ganska användbar arkitektur som det utan större
	problem går att implementera allt som krävs för att kunna köra Sphere 
	Tracing, men möjligtvis även för andra typer av problem som både är mycket
	parallella men även iterativa/rekursiva och har lite mer komplicerade 
	programflöden, vilket lätt skapar problem när de körs på locksteppade 
	arkitekturer.

	[Bild Assembler]

	Vi behövde också kunna programmera GPU:n enkelt, och därför designade vi
	ett assemblerspråk åt den. Det ser ut som de flesta assemblerspråk, men är
	lite intressant på grund av hårdvarustödet för trådar. Trådstödet gör
	faktiskt assemblern lite mer ovanlig en enbart att det finns instruktioner
	som hanterar trådar, det gjorde även att vi kunde låta bli att implementera
	jump-instruktioner, eftersom de kan ersättas genom att skapa en kopia av
	den nuvarande tråden med en instruktionspekare som pekar dit man vill
	hoppa, följt av att man terminerar den nuvarande tråden. Det låter dyrare 
	än det behöver vara, 

Square Roots:
	
	- Fast approximation
	- Improved approximation
	- Lerp/Babylonian
	- Shifting nth root
	- Sphere Tracing fault tolerance

	En central del av Sphere Tracing är att räkna ut avstȧnd, sȧ att ta 
	kvadratrötter är en operation som är viktig. Kvadratrötter implementeras 
	ofta genom att man använder ett lookup-table för en ursprunglig gissning,
	följt av nȧgra steg av en iterativ algoritm sȧsom Goldschmidt's eller den
	babylonska metoden. Vi tittade pȧ lite andra metoder, bȧde för att göra den
	ursprungliga gissningen snabbt, samt för att räkna ut kvadratrötter exakt.

	Om vi börjar med lite approximationer. [Okej sȧ här va] Om man tar
	logaritmen av ett tal fȧr man ungefär hur mȧnga siffror talet innehȧller. 
	Att ta kvadratroten av ett tal är samma som att höja upp talet i 1/2. Och
	om vi tar logaritmen av ett tal upphöjt till 1/2 följer det av 
	logaritmlagarna att det blir lika med hälften av logaritmen av talet. Altsȧ
	har kvadratroten av ett tal ungefär hälften sȧ mȧnga siffror som det 
	ursprungliga talet. Baserat pȧ det tänkte vi oss först nȧgon typ av 
	bit-shift för att lösa problemet, men baserat pȧ hur stort talet är skulle
	det behöva shiftas olika mycket, sȧ vi kom istället fram till denna 
	lösning:

	[Bild fast approx]

	Denna ger dock en dȧlig approximation för udda tvȧpotenser, sȧ vi kan 
	förbättra den genom att tända lite extra lȧga bitar för de udda 
	inputbitarna. Detta ger en bättre approximation generellt, med ett maximalt 
	reletivt fel pȧ ungefär 30%

	[Bild improved approx]

	Vi testade ocksȧ att kombinera de här gissningarna bȧde med linjär 
	interpolation mellan tvȧpotenser och med den babylonska metoden, vilket
	gav ganska bra accuracy.

	[Bild lerp/babylonian]

	Vi jobbade även med Dijkstras square root algorithm som beräknar roten ur
	på en bit åt gången. Denna algorithm var ursprungligen inte så bra för en
	högpresterande hårdvaruimplementering eftersom addition och subtraktion var
	för kostsamma. Men efter optimeringarna som vi gjorde (help) lyckades vi
	minska kostanden för addition och subraktion.

	Hur hög fel tolerans har då sphere tracing? Hur exakt måste roten ur vara
	för sphere tracen skall fungera?  Det beror på olika saker, vi har det
	satta epsilonet, sträckan som avgjorde om vi var "tillräckligt" nära för
	att säga att vi träffat. Om vi har ett större fel än vårt epsilon riskerar
	vi att overstepa och poteniellt missa objekt.  Ett annat kritiskt tillfälle
	där fel tolerans är viktigt är när vi räknar ut normalen som vi använder
	för att räkna ut reflektioner och skuggor. Får vi fel värde värde på
	normalen riskerar vi att stega i fel riktning och då reflektera fel saker
	eller få en missvisande skuggning.

Conclusion:

	- More work needed on GPU for more meaningful conclusions
	- Sphere Tracing has interesting properties

	Sphere tracing har definitivt fördelar och nackdelar kontra polygon baserad
	rendering, och det finns fortfarande mycket som kan göra sphere tracing
	bättre och snabbare. Vi har testat två optimeringar på algoritmen och visat
	att dem ökar prestandan. Men vi tror att det finns mycket mer kvar att
	lära. 

	Vi anser att det behövs läggas mer tid på alla delar i projektet för att
	kunna gör en realistisk bedömning av potentialen i en GPU  byggd för Sphere
	Tracing algoritmen. Det vi har lärt oss under vårat utförande av projektet
	är hur många delar med Sphere tracing som ännu är outforskade.	
