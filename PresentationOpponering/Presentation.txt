Sphere Tracing:
	
	VÃ¥rt projekts mÃ¥l har varit att utreda en alternativ grafikrenderingsmetod 
	som kallas Sphere Tracing, och utifrÃ¥n detta, designa en grafikprocessor 
	optimerad fÃ¶r denna. Detta ville vi gÃ¶ra eftersom man kan se att prestandan 
	fÃ¶r metoden, nÃ¤r den kÃ¶rs pÃ¥ en konventionell GPU, blir kraftigt begrÃ¤nsad. 
	Den kan dÃ¤rmed inte uppnÃ¥ sin fulla potential eftersom dagens 
	grafikhÃ¥rdvara Ã¤r designad fÃ¶r polygonbaserad grafikrendering.
	
	VarfÃ¶r just Sphere Tracing?  FÃ¶r att motivera vÃ¥rt intresse bÃ¶rjar vi med 
	att kort beskriva hur metoden fungerar, samt nÃ¥gra sÃ¤tt att fÃ¶rbÃ¤ttra 
	algoritmen, som vi kom fram till under utredningsfasen.
	
	- How Sphere Tracing works.
		Sphere Tracing Ã¤r en variant av sk Ray Tracing, vilket Ã¤r en 
		grafikrenderingsmetod baserad pÃ¥ att projicera strÃ¥lar, frÃ¥n en kamera, 
		mot en uppsÃ¤ttning av 3D-Objekt. Det objekt som strÃ¥len trÃ¤ffar fÃ¶rst 
		avgÃ¶r vilken fÃ¤rg den korresponderande pixeln pÃ¥ skÃ¤rmen kommer att fÃ¥. 
		Detta krÃ¤ver mycket datorkraft dÃ¥ man ofta mÃ¥ste lÃ¶sa 
		differentialekvationer fÃ¶r att hitta skÃ¤rningspunkterna mellan strÃ¥len  
		och objekten. Sphere Tracing Ã¤r ett alternativ till att hitta denna 
		skÃ¤rningspunkt, vilket gÃ¶rs genom att fÃ¶rst definiera alla objekt som 
		sk distansfunktioner. Dessa Ã¤r funktioner som tar en given 3d-koordinat 
		och returnerar avstÃ¥ndet till den punkt pÃ¥ funktionsytan som ligger 
		nÃ¤rmast in-koordinaten. Detta mÃ¶jliggÃ¶r en effektiv ray-marching lÃ¤ngs 
		strÃ¥len, vilket ger hÃ¶gre prestanda Ã¤n konventionell Ray Tracing. 
		(bilderbilder...)
				
	 - optimizations
		Describe each
		Show with/without optimizations to show fps difference
		visa visuellt, demonstrera hastighetsfÃ¶rbÃ¤ttring?
	- Software shader	
		berÃ¤tta att dessa optimeringar Ã¤r implementerade och testade i en sk 
		shader, ett program som kÃ¶rs pÃ¥ en GPU i en vanlig speldator. 
		(ge visuellt exempel med flowchart)		

	- Vad Ã¤r dÃ¥ Sphere tracing bra fÃ¶r?
		Denna algoritm fungerar vÃ¤ldigt annorlunda Ã¤n polyonrendering, och blir
		dÃ¤rfÃ¶r intressant dÃ¥ den kan vara vÃ¤ldigt snabb pÃ¥ mÃ¥nga
		grafikrenderingsmetoder som traditionella polygonrenderare har svÃ¥rt
		fÃ¶r. Exempel pÃ¥ detta visas hÃ¤r i vÃ¥r shader, som visar hur ytan pÃ¥ en
		sfÃ¤r kan se mjuk ut, oavsett zoom-nivÃ¥. I polygonmodellen syns skarpa
		kanter vid inzoomning, och skulle man Ã¶ka antalet polygoner fÃ¶r att
		klara kraftig inzoomning sÃ¥ skulle prestandan istÃ¤llet sÃ¤nkas alltfÃ¶r
		mycket. (visa inzoomning av 2 sfÃ¤rer nÃ¤rbild), smooth geometry blending
		between objects (kan visas med metabollarna), Ã¤kta
		reflektion/refraction (visa nÃ¥n fin interreflektion, t.ex i
		metabollarna), 
		[permutable geometry repetition]
			Ã„ven repetition av objekt i alla dimensioner gÃ¥r att gÃ¶ra med en 
			fast hastighetskostnad, till skillnad frÃ¥n det klassiska fallet som 
			har en linjÃ¤rt Ã¶kande kostnad fÃ¶r antal utritade objekt. Varje 
			repeterat objekt kan skilja sig frÃ¥n sina grannar dÃ¥ dess utseende 
			kan varieras och animeras med hjÃ¤lp av t.ex dess position eller id. 
			Detta medfÃ¶r att stora fÃ¤lt av intressant geometri kan renderas 
			extremt snabbt.	(visa animerat vÃ¥g-sfÃ¤r-fÃ¤lt),

		Ytterligare saker: penumbra-skuggning (inigos bilder?),	
		tredimensionella material,  (kanske bara skriva dessa i text pÃ¥ slides)

Processor:
	
	- Architecture overview
	- Assembler

	UtÃ¶ver detta har vi ocksÈ§ byggt en GPU, eftersom ett av mÈ§len med projektet
	var att designa hÈ§rdvara som Ã¤r gjord fÃ¶r Sphere Tracing. GPU:n som vi 
	designade blev ocksÈ§ en mer generell parallellprocessor, eftersom vi tyckte
	att det Ã¶kade mÃ¶jligheterna fÃ¶r att enkelt kunna implementera de 
	optimeringar som vi disskuterade tidigare pÈ§ processorn.

	FÃ¶r arkitekturen i sig beslutade vi att lÃ¤gga mindre fokus pÈ§ lockstepping
	Ã¤n traditionella grafikkort, dÈ§ alla rays kan variera kraftigt i antal
	steg, vilka objekt som Ã¤r nÃ¤ra, samt nÃ¤r de Ã¤r klara. KÃ¤rnorna i vÈ§r GPU
	har altsÈ§ lite mer kontrolllogik per berÃ¤kningsenhet Ã¤n traditionella
	grafikkort, men mindre, och dÃ¤rmed fler, kÃ¤rnor Ã¤n en CPU. Tillsammans med
	kÃ¤rnorna behÃ¶vs ett sÃ¤tt att representera alla de strÈ§lar som behÃ¶ver
	berÃ¤knas. 

	Vi ville ocksÈ§, om mÃ¶jligt, kunna skapa nya strÈ§lar on demand fÃ¶r att
	enkelt kunna implementera tex reflektioner och refraktioner, som Ã¤r
	relativt enkla att gÃ¶ra med raymarching, och som vore trÈ§kiga att gÈ§ miste
	om. Vi valde dÃ¤rfÃ¶r att designa GPU:n sÈ§ att alla shaders som kÃ¶r pÈ§ den
	kÃ¶r i en slags trÈ§dar, och att varje trÈ§d fÈ§r mÃ¶jligheten att spawna nya
	trÈ§dar. Sedan lade vi till en kÃ¶ som alla kÃ¤rnor kunde kommunicera med, dÃ¤r
	kÃ¤rnorna kan lÃ¤gga upp nya trÈ§dar, och hÃ¤mta trÈ§dar fÃ¶r att bÃ¶rja exekvera.

	[Bild Arkitektur]

	Detta visade sig vara en ganska anvÃ¤ndbar arkitektur som det utan stÃ¶rre
	problem gÈ§r att implementera allt som krÃ¤vs fÃ¶r att kunna kÃ¶ra Sphere 
	Tracing, men mÃ¶jligtvis Ã¤ven fÃ¶r andra typer av problem som bÈ§de Ã¤r mycket
	parallella men Ã¤ven iterativa/rekursiva och har lite mer komplicerade 
	programflÃ¶den, vilket lÃ¤tt skapar problem nÃ¤r de kÃ¶rs pÈ§ locksteppade 
	arkitekturer.

	[Bild Assembler]

	Vi behÃ¶vde ocksÈ§ kunna programmera GPU:n enkelt, och dÃ¤rfÃ¶r designade vi
	ett assemblersprÈ§k È§t den. Det ser ut som de flesta assemblersprÈ§k, men Ã¤r
	lite intressant pÈ§ grund av hÈ§rdvarustÃ¶det fÃ¶r trÈ§dar. TrÈ§dstÃ¶det gÃ¶r
	faktiskt assemblern lite mer ovanlig en enbart att det finns instruktioner
	som hanterar trÈ§dar, det gorde Ã¤ven att vi kunde lÈ§ta bli att implementera
	jump-instruktioner, eftersom de kan ersÃ¤ttas genom att spawna en kopia av
	den nuvarande trÈ§den med en instruktionspekare som pekar dit man vill
	hoppa, fÃ¶ljt av att man terminerar den nuvarande trÈ§den. Det lÈ§ter dyrare 
	Ã¤n det behÃ¶ver vara, 

Square Roots:
	
	- Fast approximation
	- Improved approximation
	- Lerp/Babylonian
	- Shifting nth root
	- Sphere Tracing fault tolerance
	
	Vi jobbade Ã¤ven med Dijkstras square root algorithm som berÃ¤knar roten ur 
	pÃ¥ en bit Ã¥t gÃ¥ngen. Denna algorithm var ursprungligen inte sÃ¥ bra fÃ¶r en
	hÃ¶gpresterande hÃ¥rdvaruimplementering


	För att kunna räkna ut längder till alla objekten i scenen behövdes roten ur användas.
	Vi insåg ganska snabbt att det det var en väldigt krävande operation, och om vi kunde
	optimera implementationen av roten ur skulle det potentiellt kunna spara både tid och
	area i GPU:n

	*Bild fast approx

	Vi hittade en snabb men grov approximering  som bara använde sig utav en rad or-gatear.
	Den utnyttjar det faktum att antalet bitar halveras vid roten ur, och ger e
	En bättre approximering är denna:

	*Bild improved approx

	Denna implementationen har fler or-gatear och deras placeringar är baserat på bit mönstret
	för roten ur 2.

	lerp/babylonian?

	shifting?

	Hur hög fel tolerans har då sphere tracing? Hur exakt måste roten ur vara för sphere tracen skall fungera?
	Det beror på olika saker, vi har det satta epsilonet, sträckan som avgjorde om vi var "tillräckligt"
	nära för att säga att vi träffat. Om vi har ett större fel än vårt epsilon riskerar vi att overstepa och 
	poteniellt missa objekt. 
	Ett annat kritiskt tillfälle där fel tolerans är viktigt är när vi räknar ut normalen som vi använder för
	 att räkna ut reflektioner och skuggor. Får vi fel värde värde på normalen riskerar vi att stega i fel riktning
	och då reflektera fel saker eller få en missvisande skuggning.
	

	

	
	

Conclusion:
	
	- More work needed on GPU for more meaningful conclusions
	- Sphere Tracing has interesting properties

	Sphere tracing har definitivt fördelar och nackdelar kontra polygon baserad rendering, och det finns fortfarande
	mycket som kan göra sphere tracing bättre och snabbare. Vi har testat två optimeringar på algoritmen och visat 
	att dem ökar prestandan. Men vi tror att det finns mycket mer kvar att lära. 

	Vi anser att det behövs läggas mer tid på alla delar i projektet för att kunna gör en realistisk bedömning av 
	potentialen i en GPU  byggd för Sphere Tracing algoritmen. Det vi har lärt oss under vårat utförande av 
	projektet är hur många delar med Sphere tracing som ännu är outforskade.	
