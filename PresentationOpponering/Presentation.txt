Sphere Tracing:
	
	V√•rt projekts m√•l har varit att utreda en alternativ grafikrenderingsmetod 
	som kallas Sphere Tracing, och utifr√•n detta, designa en grafikprocessor 
	optimerad f√∂r denna. Detta ville vi g√∂ra eftersom man kan se att prestandan 
	f√∂r metoden, n√§r den k√∂rs p√• en konventionell GPU, blir kraftigt begr√§nsad. 
	Den kan d√§rmed inte uppn√• sin fulla potential eftersom dagens 
	grafikh√•rdvara √§r designad f√∂r polygonbaserad grafikrendering.
	
	Varf√∂r just Sphere Tracing?  F√∂r att motivera v√•rt intresse b√∂rjar vi med 
	att kort beskriva hur metoden fungerar, samt n√•gra s√§tt att f√∂rb√§ttra 
	algoritmen, som vi kom fram till under utredningsfasen.
	
	- How Sphere Tracing works.
		Sphere Tracing √§r en variant av sk Ray Tracing, vilket √§r en 
		grafikrenderingsmetod baserad p√• att projicera str√•lar, fr√•n en kamera, 
		mot en upps√§ttning av 3D-Objekt. Det objekt som str√•len tr√§ffar f√∂rst 
		avg√∂r vilken f√§rg den korresponderande pixeln p√• sk√§rmen kommer att f√•. 
		Detta kr√§ver mycket datorkraft d√• man ofta m√•ste l√∂sa 
		differentialekvationer f√∂r att hitta sk√§rningspunkterna mellan str√•len  
		och objekten. Sphere Tracing √§r ett alternativ till att hitta denna 
		sk√§rningspunkt, vilket g√∂rs genom att f√∂rst definiera alla objekt som 
		sk distansfunktioner. Dessa √§r funktioner som tar en given 3d-koordinat 
		och returnerar avst√•ndet till den punkt p√• funktionsytan som ligger 
		n√§rmast in-koordinaten. Detta m√∂jligg√∂r en effektiv ray-marching l√§ngs 
		str√•len, vilket ger h√∂gre prestanda √§n konventionell Ray Tracing. 
		(bilderbilder...)
				
	 - optimizations
		Describe each
		Show with/without optimizations to show fps difference
		visa visuellt, demonstrera hastighetsf√∂rb√§ttring?

		- Orthogonal Culling
			Orthogonal Culling anv‰nds fˆr att minska antalet distans-f‰lt 
			utr‰kningar som behˆver gˆras per steg genom att r‰kna ut vilka
			objekt i scenen som strÂlen kan tr‰ffa. Varje strÂle fˆljer en 
			linje, genom att ortogonalt projicera objekts centrum pÂ linjen
			kan man r‰kna ut om de ligger framfˆr strÂlen eller inte. Om 
			objektet inte ligger framfˆr strÂlen sÂ slutar man r‰kna ut 
			avstÂndet till det, fˆr det kan inte tr‰ffas ‰ndÂ.

		- Bounding Sphere
			Bounding Spheres anv‰nds fˆr att minska antalet utr‰kningar som 
			behˆver gˆras innan strÂlen ‰r i n‰rheten av objekt som den kanske
			kommer tr‰ffa. Flera objekt placeras inuti en stˆrre sf‰r, 
			ist‰llet fˆr att r‰kna ut avstÂndet till alla objekt sÂ anv‰nds
			bara sf‰ren. Om en strÂle tr‰ffar en Bounding Sphere sÂ tas den bort
			och alla objekt inuti anv‰nds igen. 



	- Software shader	
		ber√§tta att dessa optimeringar √§r implementerade och testade i en sk 
		shader, ett program som k√∂rs p√• en GPU i en vanlig speldator. 
		(ge visuellt exempel med flowchart)		

	- Vad √§r d√• Sphere Tracing bra f√∂r?
		Denna algoritm fungerar v√§ldigt annorlunda √§n polygonrendering, och blir
		d√§rf√∂r intressant d√• den kan vara v√§ldigt snabb p√• m√•nga
		grafikrenderingsmetoder som traditionella polygonrenderare har sv√•rt
		f√∂r. Exempel p√• detta visas h√§r i v√•r shader, som visar hur ytan p√• en
		sf√§r kan se mjuk ut, oavsett zoom-niv√•. I polygonmodellen syns skarpa
		kanter vid inzoomning, och skulle man √∂ka antalet polygoner f√∂r att
		klara kraftig inzoomning s√• skulle prestandan ist√§llet s√§nkas alltf√∂r
		mycket. (visa inzoomning av 2 sf√§rer n√§rbild), 
		mjuk geometri-blending mellan objekt (kan visas med metabollarna), √§kta
		reflektion/refraktion (visa n√•n fin interreflektion, t.ex i
		metabollarna), 
		[permuterbar geometrirepetition]
			√Ñven repetition av objekt i alla dimensioner g√•r att g√∂ra med en 
			fast hastighetskostnad, till skillnad fr√•n det klassiska fallet som 
			har en linj√§rt √∂kande kostnad f√∂r antal utritade objekt. Varje 
			repeterat objekt kan skilja sig fr√•n sina grannar d√• dess utseende 
			kan varieras och animeras med hj√§lp av t.ex dess position eller id. 
			Detta medf√∂r att stora f√§lt av intressant geometri kan renderas 
			extremt snabbt.	(visa animerat v√•g-sf√§r-f√§lt),

		Ytterligare saker: penumbra-skuggning (inigos bilder?),	
		tredimensionella material,  (kanske bara skriva dessa i text p√• slides)

Processor:
	
	- Architecture overview
	- Assembler

	Ut√∂ver detta har vi ocks√• byggt en GPU, eftersom ett av m√•len med projektet
	var att designa h√•rdvara som √§r gjord f√∂r Sphere Tracing. GPU:n som vi 
	designade blev ocks√• en mer generell parallellprocessor, eftersom vi tyckte
	att det √∂kade m√∂jligheterna f√∂r att enkelt kunna implementera de 
	optimeringar som vi diskuterade tidigare p√• processorn.

	F√∂r arkitekturen i sig beslutade vi att l√§gga mindre fokus p√• lockstepping
	√§n traditionella grafikkort, d√• alla rays kan variera kraftigt i antal
	steg, vilka objekt som √§r n√§ra, samt n√§r de √§r klara. K√§rnorna i v√•r GPU
	har allts√• lite mer kontrolllogik per ber√§kningsenhet √§n traditionella
	grafikkort, men mindre, och d√§rmed fler, k√§rnor √§n en CPU. Tillsammans med
	k√§rnorna beh√∂vs ett s√§tt att representera alla de str√•lar som beh√∂ver
	ber√§knas. 

	Vi ville ocks√•, om m√∂jligt, kunna skapa nya str√•lar on demand f√∂r att
	enkelt kunna implementera t.ex. reflektioner och refraktioner, som √§r
	relativt enkla att g√∂ra med raymarching, och som vore tr√•kiga att g√• miste
	om. Vi valde d√§rf√∂r att designa GPU:n s√• att alla shaders som k√∂r p√• den
	k√∂r i en slags tr√•dar, och att varje tr√•d f√•r m√∂jligheten att skapa nya
	tr√•dar. Sedan lade vi till en k√∂ som alla k√§rnor kunde kommunicera med, d√§r
	k√§rnorna kan l√§gga upp nya tr√•dar, och h√§mta tr√•dar f√∂r att b√∂rja exekvera.

	[Bild Arkitektur]

	Detta visade sig vara en ganska anv√§ndbar arkitektur som det utan st√∂rre
	problem g√•r att implementera allt som kr√§vs f√∂r att kunna k√∂ra Sphere 
	Tracing, men m√∂jligtvis √§ven f√∂r andra typer av problem som b√•de √§r mycket
	parallella men √§ven iterativa/rekursiva och har lite mer komplicerade 
	programfl√∂den, vilket l√§tt skapar problem n√§r de k√∂rs p√• locksteppade 
	arkitekturer.

	[Bild Assembler]

	Vi beh√∂vde ocks√• kunna programmera GPU:n enkelt, och d√§rf√∂r designade vi
	ett assemblerspr√•k √•t den. Det ser ut som de flesta assemblerspr√•k, men √§r
	lite intressant p√• grund av h√•rdvarust√∂det f√∂r tr√•dar. Tr√•dst√∂det g√∂r
	faktiskt assemblern lite mer ovanlig en enbart att det finns instruktioner
	som hanterar tr√•dar, det gjorde √§ven att vi kunde l√•ta bli att implementera
	jump-instruktioner, eftersom de kan ers√§ttas genom att skapa en kopia av
	den nuvarande tr√•den med en instruktionspekare som pekar dit man vill
	hoppa, f√∂ljt av att man terminerar den nuvarande tr√•den. Det l√•ter dyrare 
	√§n det beh√∂ver vara, 

Square Roots:
	
	- Fast approximation
	- Improved approximation
	- Lerp/Babylonian
	- Shifting nth root
	- Sphere Tracing fault tolerance
	
	F√∂r att kunna r√§kna ut l√§ngder till alla objekten i scenen beh√∂vdes roten
	ur anv√§ndas.  Vi ins√•g ganska snabbt att det det var en v√§ldigt kr√§vande
	operation, och om vi kunde optimera implementationen av roten ur skulle det
	potentiellt kunna spara b√•de tid och area i GPU:n

	*Bild fast approx

	Vi hittade en snabb men grov approximering  som bara anv√§nde sig utav en
	rad or-gatear.  Den utnyttjar det faktum att antalet bitar halveras vid
	roten ur, och ger e En b√§ttre approximering √§r denna:

	*Bild improved approx

	Denna implementationen har fler or-gatear och deras placeringar √§r baserat
	p√• bit m√∂nstret f√∂r roten ur 2.

	lerp/babylonian?

	shifting?
	
	Vi jobbade √§ven med Dijkstras square root algorithm som ber√§knar roten ur
	p√• en bit √•t g√•ngen. Denna algorithm var ursprungligen inte s√• bra f√∂r en
	h√∂gpresterande h√•rdvaruimplementering eftersom addition och subtraktion var
	f√∂r kostsamma. Men efter optimeringarna som vi gjorde (help) lyckades vi
	minska kostanden f√∂r addition och subraktion.

	Hur h√∂g fel tolerans har d√• sphere tracing? Hur exakt m√•ste roten ur vara
	f√∂r sphere tracen skall fungera?  Det beror p√• olika saker, vi har det
	satta epsilonet, str√§ckan som avgjorde om vi var "tillr√§ckligt" n√§ra f√∂r
	att s√§ga att vi tr√§ffat. Om vi har ett st√∂rre fel √§n v√•rt epsilon riskerar
	vi att overstepa och poteniellt missa objekt.  Ett annat kritiskt tillf√§lle
	d√§r fel tolerans √§r viktigt √§r n√§r vi r√§knar ut normalen som vi anv√§nder
	f√∂r att r√§kna ut reflektioner och skuggor. F√•r vi fel v√§rde v√§rde p√•
	normalen riskerar vi att stega i fel riktning och d√• reflektera fel saker
	eller f√• en missvisande skuggning.

Conclusion:
	
	- More work needed on GPU for more meaningful conclusions
	- Sphere Tracing has interesting properties

	Sphere tracing har definitivt f√∂rdelar och nackdelar kontra polygon baserad
	rendering, och det finns fortfarande mycket som kan g√∂ra sphere tracing
	b√§ttre och snabbare. Vi har testat tv√• optimeringar p√• algoritmen och visat
	att dem √∂kar prestandan. Men vi tror att det finns mycket mer kvar att
	l√§ra. 

	Vi anser att det beh√∂vs l√§ggas mer tid p√• alla delar i projektet f√∂r att
	kunna g√∂r en realistisk bed√∂mning av potentialen i en GPU  byggd f√∂r Sphere
	Tracing algoritmen. Det vi har l√§rt oss under v√•rat utf√∂rande av projektet
	√§r hur m√•nga delar med Sphere tracing som √§nnu √§r outforskade.	
